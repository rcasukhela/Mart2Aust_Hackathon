{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    " 1 contributor\n",
    "180 lines (122 sloc) 4.2 KB\n",
    "function [V,F,I_FD] = spatialDecomposition(X,unitCell,varargin)\n",
    "% decomposite the spatial domain into cells D with vertices V,\n",
    "%\n",
    "% Output\n",
    "%  V - list of vertices\n",
    "%  F - list of faces\n",
    "%  I_FD - incidence matrix between faces to cells\n",
    "\n",
    "% compute voronoi decomposition\n",
    "% V - list of vertices of the Voronoi cells\n",
    "% D   - cell array of Vornoi cells with centers X_D ordered accordingly\n",
    "if isempty(unitCell), unitCell = calcUnitCell(X); end\n",
    "\n",
    "if check_option(varargin,'unitCell')\n",
    "  \n",
    "  % compute the vertices\n",
    "  [V,faces] = generateUnitCells(X,unitCell,varargin{:});\n",
    " \n",
    "  D = cell(size(X,1),1);\n",
    "  for k=1:size(X,1)  \n",
    "    D{k} = faces(k,:);\n",
    "  end\n",
    "  \n",
    "else\n",
    "  \n",
    "  dummyCoordinates = calcBoundary(X,unitCell,varargin{:});\n",
    "\n",
    "  [V,D] = voronoin([X;dummyCoordinates],{'Q5','Q6','Qs'}); %,'QbB'\n",
    "\n",
    "  D = D(1:size(X,1));\n",
    "  \n",
    "end\n",
    "\n",
    "% now we need some adjacencies and incidences\n",
    "iv = [D{:}];            % nodes incident to cells D\n",
    "id = zeros(size(iv));   % number the cells\n",
    "    \n",
    "p = [0; cumsum(cellfun('prodofsize',D))];\n",
    "for k=1:numel(D), id(p(k)+1:p(k+1)) = k; end\n",
    "    \n",
    "% next vertex\n",
    "indx = 2:numel(iv)+1;\n",
    "indx(p(2:end)) = p(1:end-1)+1;\n",
    "ivn = iv(indx);\n",
    "\n",
    "% edges list\n",
    "F = [iv(:), ivn(:)];\n",
    "\n",
    "% should be unique (i.e one edge is incident to two cells D)\n",
    "[F, ~, ie] = unique(sort(F,2),'rows');\n",
    "\n",
    "% faces incident to cells, F x D\n",
    "I_FD = sparse(ie,id,1);\n",
    "\n",
    "end\n",
    "\n",
    "\n",
    "\n",
    "function dummyCoordinates = calcBoundary(X,unitCell,varargin)\n",
    "% dummy coordinates so that the voronoi-cells of X are finite\n",
    "\n",
    "dummyCoordinates = [];\n",
    "\n",
    "% specify a bounding polyogn\n",
    "boundary = get_option(varargin,'boundary','hull',{'char','double'});\n",
    "\n",
    "if ischar(boundary)\n",
    "  \n",
    "  switch lower(boundary)\n",
    "    case {'hull','convexhull'}\n",
    "      x = X(:,1);  y = X(:,2);\n",
    "\n",
    "      k = convhull(x,y);\n",
    "      \n",
    "      % erase all linear dependend points\n",
    "      angle = atan2( x(k(1:end-1))-x(k(2:end)),...\n",
    "        y(k(1:end-1))-y(k(2:end)) );      \n",
    "      k = k([true; abs(diff(angle))>eps; true]);\n",
    "      \n",
    "      boundingX = X(k,:);\n",
    "      \n",
    "    case 'cube'\n",
    "      \n",
    "      % set up a rectangular box\n",
    "      envelopeX = [min(X); max(X)];\n",
    "      boundingX = [ ...\n",
    "        envelopeX(1),envelopeX(3);\n",
    "        envelopeX(2),envelopeX(3);\n",
    "        envelopeX(2),envelopeX(4);\n",
    "        envelopeX(1),envelopeX(4);\n",
    "        envelopeX(1),envelopeX(3) ];\n",
    "      \n",
    "    otherwise     \n",
    "      \n",
    "      error('uknown boundary type. Available options are ''convexhull'' and ''cube''.');   \n",
    "      \n",
    "  end\n",
    "  \n",
    "elseif isa(boundary,'double')\n",
    "  \n",
    "  boundingX = boundary;\n",
    "  \n",
    "end\n",
    "\n",
    "\n",
    "radius = mean(sqrt(sum(unitCell.^2,2)));\n",
    "edgeLength = sqrt(sum(diff(boundingX).^2,2));\n",
    "\n",
    "% fill each line segment with nodes every 20 points (in average)\n",
    "nto = fix((edgeLength>0)*4); fix(edgeLength*(2*radius));\n",
    "\n",
    "cs = cumsum([1; 1 + nto]);\n",
    "boundingX(cs,:) = boundingX;\n",
    "\n",
    "% interpolation\n",
    "for k=1:numel(nto)\n",
    "  for dim=1:2\n",
    "    boundingX(cs(k):cs(k+1),dim) = ...\n",
    "      linspace(boundingX(cs(k),dim), boundingX(cs(k+1), dim),nto(k)+2);\n",
    "  end  \n",
    "end\n",
    "\n",
    "\n",
    "% homogeneous coordinates\n",
    "X(:,3) = 1;\n",
    "boundingX(:,3) = 1;\n",
    "\n",
    "% householder matrix\n",
    "H = @(v) eye(3) - 2./(v(:)'*v(:))*(v(:)*v(:)') ;\n",
    "% translation matrix\n",
    "T  = @(s) [ 1 0 s(1); 0 1 s(2); 0 0 1];\n",
    "\n",
    "% direction of the edge\n",
    "edgeDirection = diff(boundingX);\n",
    "edgeAngle = atan2(edgeDirection(:,2),edgeDirection(:,1));\n",
    "edgeLength = sqrt(sum(edgeDirection.^2,2));\n",
    "\n",
    "% shift the starting vertex\n",
    "bX = squeeze(double(axis2quat(zvector,edgeAngle)* ...\n",
    "  vector3d([0; radius; 1])));\n",
    "offsetX = bX - boundingX(1:end-1,:);\n",
    "\n",
    "for k=1:size(boundingX,1)-1\n",
    "  \n",
    "  % mirror the point set X on each edge\n",
    "  pX = X * -(T(offsetX(k,:)) * H(edgeDirection(k,:)) * T(offsetX(k,:)))';\n",
    "  \n",
    "  % distance between original and mirrowed point\n",
    "  dist = sqrt(sum((X(:,1:2)-pX(:,1:2)).^2,2));\n",
    " \n",
    "  intendX = 2*radius*sign(edgeDirection(k,1:2));\n",
    "  \n",
    "  % now try to delete unnecessary points\n",
    "  m = 2;\n",
    "  while true\n",
    "    \n",
    "    tmpX = pX(dist < m*radius,1:2);\n",
    "    \n",
    "    right = (bsxfun(@minus, tmpX, boundingX(k,1:2)  - intendX ) * edgeDirection(k,1:2)') < 0;\n",
    "    left  = (bsxfun(@minus, tmpX, boundingX(k+1,1:2)+ intendX ) * edgeDirection(k,1:2)') > 0;\n",
    "   \n",
    "    tmpX = tmpX( ~(right | left) ,:);\n",
    "     \n",
    "    if edgeLength(k)/size(tmpX,1) < radius/3, \n",
    "      break;\n",
    "    elseif m < 2^7, \n",
    "      m = m*2;\n",
    "    else\n",
    "      m = m+10; \n",
    "    end\n",
    "    \n",
    "  end\n",
    "  \n",
    "  dummyCoordinates = [dummyCoordinates; tmpX];\n",
    "  \n",
    "end\n",
    "  \n",
    "dummyCoordinates = unique(dummyCoordinates,'first','rows');\n",
    "\n",
    "end\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
